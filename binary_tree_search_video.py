# Animate a Binary Search Tree using Python, GraphViz, and ffmeg utility
# Revision 2: 12/23/2013
#
# Input: A binary search tree with a known root node to sketch.
#        A search algorithm to animate.
#        Examples are included to:
#            1) create binary search trees, manually created, unbalanced, and balanced,
#            2) search methods for breadth first, depth first, and ordered depth first,
# Output: This demo software presents two forms of graphic animation,
#         1) A png graphic image file showing the tree structure, and 
#         2) A series of png images to create video animations of search trail.

# Project home: http://www.embeddedcomponents.com/blogs/2013/12/visualizing-software-tree-structures/

# Inspired by MITx 6.00.1x "Introduction to Computer Science and Programming"
# As taught by Professor Eric Grimson, Chairman of EECS Department, MIT
# Fall 2013, http://www.edx.org

# Developed by Ron Fredericks, Video Technologist, at LectureMaker LLC, http://www.LectureMaker.com
# MIT License, Copyright (c) 2013, Ron Fredericks
# Free to use following these terms: http://opensource.org/licenses/MIT 

# This project allows you to do the following:
#   1) design any searchable tree class, then instantiate the tree with data,
#       see "class binaryTree(object)" in this demo.
#   2) Use the provided "class visualizeTree(object)" to create a PNG image of the tree
#       as well as to create a sequence of PNG images for use in generating a video of the search path.
#   2-a) Helper functions "DFS()", "BFS()", and "DFSOrdered() can be used to animate searching the tree by depth or breadth,
#       or use the code to create your own helper functions to test your own search algorithms.
#   2-b) sketchTree
#   3) The code completes with a PNG graphical display of the last image generated by this program,
#       to help you determine if this run of the program is useful for creation of mpeg4 video.
#   4) Generate an mpeg-4 video using the PNG image sequence generated by the "visualizeTree object",
#       Command line example (use double "%%" if this command is in a Windows batch file): 
#       ffmpeg -f image2 -r 1 -start_number 00001 -i bst_graph%05d.png -vcodec mpeg4 -r 12 -y movie.mp4

# The following free open source programs should be installed on your computer:
#   GraphViz: Graph visualization tool: http://www.graphviz.org/ 
#   FFmpeg: Cross-platform solution to record, convert and stream audio and video: http://www.ffmpeg.org/

# The following python module should be installed into your environment:
#   pydot: a python interface to Graphvize's Dot language: https://code.google.com/p/pydot/

# The following python modules are used for display of individual PNG images:
#   Tkinter: standard python GUI: https://wiki.python.org/moin/TkInter
#   Image and ImageTk: the python image library: http://www.pythonware.com/products/pil/ 


#############################
# User Controlled Parameters 
#############################

# Define a sorted or unsorted list named "listForTree", with key values to generate a tree
#   Control which builtin algorithm to use to build tree: 
#        rootValue set to None for balanced tree using function buildBalancedTree, or 
#        rootValue set to a value within listForTree for unbalanced using function buildUnbalancedTree
# Define a value to animate during a search using "findValue", as a string 

# build a balanced tree from a sorted list
#--------------------------------------------------------------------------------------

# Build a tree using an integer list. The root value is determined automatically
'''
listForTree = sorted([5,2,1,4,8,6,7,3])
rootValue = None   # Note: None will be replaced by the midpoint of the list
findValue = '8'
'''

# build a tree using a character list. The root value is determined automatically
'''
listForTree = [c for c in 'abcdefghijklmnopqrstuvwxyz']
rootValue = None   # Note: None will be replaced by the midpoint of the list
findValue = 'z'
'''

# build an unbalanced tree using from an unsorted list. 
#---------------------------------------------------------------------------------------

# Build a tree using an integer list. The root value is determined manually 
listForTree = [5,2,1,4,8,6,7,3]
rootValue = 5   # Note: Select a root key from the list of elements in listForTree
findValue = '7'

# longer alpha demo with randomly shuffled tree data, and random choice for search value
'''
import random
listForTree = [c for c in 'abcdefghijklmnopqrstuvwxyz']
rootValue = listForTree[len(listForTree)/2] # Note: Select a root key from the list of elements in listForTree
random.shuffle(listForTree)
findValue = random.choice(listForTree)
'''


# select a predefined search function from these options: '', 'DFS' | 'BFS' | 'DFSOrdered'
# Where an empty searchName indicates no search to be performed or animated
#------------------------------------------------------------------------------------

#searchName = ''  # Don't search
searchName = 'DFSOrdered'


# Define path where PNG images will be stored
#--------------------------------------------
fileDir = "C:\\Users\\Ron Fredericks\\Documents\\LectureMaker\\Projects\\MOOC\\EDx\\cs600.1\\Video\\vidImages\\"


###############################################
# The Remaining Code Below Need Not Be Touched
###############################################

# import the python inteface package to the graphviz program
import pydot

# import the graphics packages used to display an image
import Tkinter 
import Image, ImageTk

# History:
#   Initial project published on 12/11/2013
#
#   Rev 1: 12/16/2013
#       1) Improve automated tree graphic image design so that no node is displayed directly below its parent. 
#            a) add invisible nodes, and invisible edges as placeholders to replace leaves that are not in the tree definition,
#            b) change the default weight of edges to zero, so that displayed trees have freedom to spread out on the canvas.
#       2) Redesign the draw() method to support automated inclusion of invisible nodes when a left or right sibling is missing from tree,
#           remove automated display of "root", "node", and "leaf" in the node label.
#       3) Redesign search routines BFS, and DEF so that drawing of graphic image information is not mixed in. 
#            Now new search routines can be designed solely on the merits of search.
#       4) Add a new search routine: DFSOrdered.
#       5) Add a new drawing routine: sketchTree.
#           This routine adds the drawing information previously mixed into the search routines.
#           Use this routine once to draw the full tree image during initialization.
#       6) Change method blinkNodeTraversed color scheme to show a history of nodes searched in a new color
#       7) Improve comments for accuracy.
#
#   Rev 2: 12/23/2013
#       1) Provide 3 tree generation options: manually create tree, generate random unbalanced tree, create balanced tree
#       2) Improve draw method to include left, right, and middle "invisible" nodes and intelligent edge weights,
#            now all edges in same direction are parallel, and every node of the same depth is displayed at the same depth
#       3) Fix bug in DFSOrdered() search function
#       4) Provide an initiallization segment near the top of the code to simplify control of tree sketching and search animation
#       5) Clean up PNG image display code
#       6) Improve video scaling: 
#            a) support large trees
#            b) support HD video during graph generation and in FFmpeg for 1920 x 1080 pixel size
#        New FFmpeg command line to generate intelligently scaled video in HD from PNG image sequences:
#        ffmpeg -f image2 -r 1 -start_number 00001 -i bst_graph%%05d.png  -b:v 5000k -vcodec mpeg4 -r 30 -vf scale="'if(gt(a,4/3),1920,-1)':'if(gt(a,4/3),-1,1280)'" -y movie.mp4
#       


###########################################
# Create a binary search tree
###########################################

# This code can be replaced with any experimental tree

class binaryTree(object):
    def __init__(self, value):
        self.value = value
        self.leftBranch = None
        self.rightBranch = None
        self.parent = None 
    def setLeftBranch(self, node):
        self.leftBranch = node
    def setRightBranch(self, node):
        self.rightBranch = node
    def setParent(self, parent):
        self.parent = parent
    def getValue(self):
        return self.value
    def getLeftBranch(self):
        return self.leftBranch
    def getRightBranch(self):
        return self.rightBranch
    def getParent(self):
        return self.parent

    def insert(self, value):
        """
        Insert new node with data key set to value
        return node object to caller
        Modified from reference: http://www.laurentluce.com/posts/binary-search-tree-library-in-python/
        """
        if value < self.value:
            if self.getLeftBranch() is None:
                self.setLeftBranch(binaryTree(value))
                self.getLeftBranch().setParent(self)
                return self.getLeftBranch()
            else:
                self.getLeftBranch().insert(value)
        else:
            if self.getRightBranch() is None:
                self.setRightBranch(binaryTree(value))
                self.getRightBranch().setParent(self)
                return self.getRightBranch()
            else:
                self.getRightBranch().insert(value)

    def lookup(self, value):
        """
        Lookup node containing data key set to value
        returns node object to caller, or None if not found
        Modified from reference: http://www.laurentluce.com/posts/binary-search-tree-library-in-python/
        """
        if value < self.value:
            if self.getLeftBranch is None:
                return None
            return self.getLeftBranch().lookup(value)
        elif value > self.value:
            if self.getRightBranch() is None:
                return None
            return self.getRightBranch().lookup(value)
        else:
            return self           
        
    def __str__(self):
        return str(self.value)


'''
A Manual Method to Instantiate a Tree

n5 = binaryTree(5)
n2 = binaryTree(2)
n1 = binaryTree(1)
n4 = binaryTree(4)
n8 = binaryTree(8)
n6 = binaryTree(6)
n7 = binaryTree(7)
n3 = binaryTree(3)

n5.setLeftBranch(n2)
n2.setParent(n5)
n5.setRightBranch(n8)
n8.setParent(n5)
n2.setLeftBranch(n1)
n1.setParent(n2)
n2.setRightBranch(n4)
n4.setParent(n2)
n8.setLeftBranch(n6)
n6.setParent(n8)
n6.setRightBranch(n7)
n7.setParent(n6)
n4.setLeftBranch(n3)
n3.setParent(n4)

# define sketch tree and animate search parameters
root = n5
findValue = '7'
listForTree = None
'''


def buildBalancedTree(sortedList, start, end):
    """
    Build a balanced binary search tree from sorted linked list.

    This assumes that you have a class BinarySearchTree, with methods
    'getLeftBranch()', 'getRightBranch()' and optionally setParent().

    Params:
        sortedList: sorted list, any data structure with 'pop(0)' method,
            which removes and returns the leftmost element of the list. The
            easiest thing to do is to use a list for the sorted
            list.
        start: int, start index, on initial call set to 0
        end: int, on initial call should be set to len(sortedList)

    Returns:
        A balanced instance of binaryTree
        
    References:
        The original python implementation used a sorted "linked" list found here:
            http://leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html
        Based on an original solution in C found here: 
            http://leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html
    """

    if start >= end:
        return None

    middle = (start + end) // 2
    node = buildBalancedTree(sortedList, start, middle)
    root = binaryTree(sortedList.pop(0))
    root.setLeftBranch(node)
    if root.getLeftBranch():
        root.getLeftBranch().setParent(root)    
    root.setRightBranch(buildBalancedTree(sortedList, middle+1, end))
    if root.getRightBranch():
        root.getRightBranch().setParent(root)      
    return root      


# A programmatic method to build an unbalanced binary tree (for demo purposes)

def buildUnbalancedTree(unsortedList, rootValue):
    """
    Build an unbalanced binary search tree
    Input: A list of key values to generate a tree, 
           The root key value, a member of the unsortedList           
    Output: rootNode when rootValue was found in unsortedList, otherwise return None         
    Notes:
        The unsortedList list is destroyed during the process
        The nodes will be inserted into the tree using unsortedList list from left to right
    """
    if rootValue not in unsortedList:
        return None
    rootIndex = unsortedList.index(rootValue)
    rootNode = binaryTree(unsortedList[rootIndex])
    unsortedList.remove(unsortedList[rootIndex])
    while len(unsortedList):           
        rootNode.insert(unsortedList[0])
        unsortedList.remove(unsortedList[0])
    return rootNode                       
   

if not rootValue:
    print "Generate a balanced tree"   
    root = buildBalancedTree(listForTree[:], 0, len(listForTree))
else:
    print "Generate an unbalanced tree" 
    root = buildUnbalancedTree(listForTree[:], rootValue)
if not root:
    print "Error: tree not built"
    raw_input("Press return key to continue: ")


# display 'sketch tree' and 'animate search' parameters
print "root value:", root.getValue()
print "search for:", findValue
print "List for tree:", str(listForTree)


#############################################################
# Graph tree as a png file - an object with helper functions
#############################################################
             
# Class to generate a binary search tree drawing, 
#   or to search for and draw highlight images of the tree's nodes.
# External helper search method functions supported: DFS() and BFS()  

class visualizeTree(object):
    def __init__(self, fileCount, fileDir, fileName, fileExt, vidFrames):
        self.fileCount = fileCount  # integer, part of the fullFileName when generating PNG image sequences
        self.fileDir = fileDir      # string, full directory to where PNG files will be stored
        self.fileName = fileName    # string, base name of the file 
        self.fileExt = fileExt      # string, image file extension (currently ".png" is the only supported type)
        self.vidFrames = vidFrames  # integer, a counter used generate duplicate copies of the PNG image files,
                                    #   a way to stretch the video time line.
        
        self.treeList = []       # storage for the DFS or BFS tree search as a queue or stack
        self.nodeNames = {}      # store each node name (key) with each node's pyDot object (value)
        self.fullFileName = ""   # store the current full file name for png images

    # Method to control the number of duplicate png images to generate (ie stretch or shrink video time)        
    def setVidFrames(self, vidFrames):
        self.vidFrames = vidFrames

    # Method to search a binary tree
    # Input:
    #     searchMethod is a helper function that defines the type of search to perform, 
    #        current examples implemented: DFS, BFS, and DFSOrdered
    #     find is string representing the node to search and highlight, or None to display full binary tree 
    # Output:
    #     True if node is found, or False if node is not found, or False when drawing the full tree (not searching)  
    def searchTree(self, root, searchMethod, find=None):
        self.treeList = [root]
        while len(self.treeList) > 0:
            node = self.treeList.pop(0)
            #print str(node) # activate to display nodes searched when debug needed
            if find==str(node):
                self.highlightNodeFound(str(node))
                return True
            elif find!=None:
                self.blinkNodeTraversed(str(node))            
            searchMethod(node, self.treeList, find, self.draw)    
        return False

    # Method to draw a node and an edge of a Binary Tree
    # Input:
    #   parent_name is a string lable identifying the parent node to draw (if not drawn already)
    #   child_name is a string lable identifying the child node to draw
    #   fill_color is the color to fill nodes drawn
    #   style_type is either "filled" for normal drawing of tree nodes, or "invisible" for drawing nodes not part of tree
    def draw(self, parent_name, child_name, fill_color="grey", style_type='filled'):
                   
        if style_type=="invisible":
            # save original edge defaults
            weight_ = "100"
            saveEdgeDefaults = graph.get_edge_defaults()[0]
            graph.set_edge_defaults(style=style_type, color="white", arrowhead="none")  # comment during debug
            ###fill_color="#6699cc"  # debug, display invisible edges and nodes as light blue
            ###style_type="filled"   # debug, display invisible edges and nodes as light blue  
        else:
            weight_ = "3"
        edge = pydot.Edge(parent_name, child_name, style=style_type, weight=weight_)
        graph.add_edge(edge)  
        if style_type=="invisible":
            # restore original edge defaults
            graph.set_edge_defaults(**saveEdgeDefaults)        

        if not self.nodeNames:
            # root node identified (the top most tree element)
            self.nodeNames[parent_name] = pydot.Node(parent_name, label=parent_name, fillcolor=fill_color, style=style_type)
            graph.add_node(self.nodeNames[parent_name]) 
        if (parent_name not in self.nodeNames):
            # node (a tree element with leaves) identified       
            self.nodeNames[parent_name] = pydot.Node(parent_name, label=parent_name, fillcolor=fill_color, style=style_type)
            graph.add_node(self.nodeNames[parent_name])
        if child_name not in self.nodeNames:
            # leaf element identified (a parent with no children) 
            self.nodeNames[child_name] = pydot.Node(child_name, label=child_name, fillcolor=fill_color, style=style_type)
            graph.add_node(self.nodeNames[child_name])
              
    # Method to animate the found node in a search tree        
    def highlightNodeFound(self, node):
        graph.add_node(pydot.Node(node, fillcolor="green"))
        self.updateGraph()      

    # Method to animate a node being traversed in a search tree    
    def blinkNodeTraversed(self, node):
        graph.add_node(pydot.Node(node, fillcolor="red"))
        self.updateGraph()
        # use a redish grey color #cc9999 to show a breadcrumb to searched nodes in tree
        graph.add_node(pydot.Node(node, fillcolor="#cc9999"))
        self.updateGraph()        
        
    # Method to set the file name based on directory, name, count and extension in support of our ffmpeg png to video batch file       
    def setFileName(self):
        self.fullFileName = self.fileDir + self.fileName + '%05d' % self.fileCount + self.fileExt
    
    # Method to get the current full file name 
    def getFileName(self):
        return self.fullFileName
    
    # Method to write multiple copies of the same png image in support of ffmpeg png to video batch file
    def updateGraph(self):
        for i in range(0, self.vidFrames):
            self.fileCount += 1
            self.setFileName()
            graph.write_png(self.fullFileName)   

# Helper search method functions for use with visualizeTree's method named "searchTree()"

# Depth First Search: Start at root followed by all nodes on left followed by right.
# Uses a Queue: First in First out (FIFO)  
# Updates a graph of a Binary Tree 
# Unused: find and draw
def DFS(node, queue, find=None, draw=None):
    if node.getRightBranch():
        queue.insert(0, node.getRightBranch())
    if node.getLeftBranch():
        queue.insert(0, node.getLeftBranch())   

# Depth First OrderedSearch: 
#   Uses binary search tree structure to make an intelligent search.  
# Updates a graph of a Binary Tree 
# Unused: draw              
def DFSOrdered(node, queue, find, draw=None):                                                             
    if node.getRightBranch() and find > node.getValue():
        queue.insert(0, node.getRightBranch())
    else: # node.getLeftBranch() and find < node.getValue():
        queue.insert(0, node.getLeftBranch())    
         

                
# Breadth First Search: Start at root followed by each child from left to right
# Uses a Stack: Last in First out (LIFO)    
# Updates a graph of a Binary Tree 
# Unused: find and draw
def BFS(node, stack, find=None, draw=None):
    if node.getLeftBranch():
        stack.append(node.getLeftBranch())       
    if node.getRightBranch():
        stack.append(node.getRightBranch())          

# Sketch complete tree
# makes calls to visualizeTree's draw() method to graph edge and node elements
# Input: node in binary tree, stack for depth first drawing
# Unused: find
def sketchTree(node, stack, find=None, draw=None):
    if node.getLeftBranch():
        draw(str(node), str(node.getLeftBranch()))
        stack.append(node.getLeftBranch()) 
        if node.getRightBranch():
            # insert invisible thrid node inbetween left and right nodes
            draw(str(node), ":"+str(node), style_type="invisible")
    elif node.getRightBranch():
        # draw any missing left branchs as invisible nodes/edges with dummy unique lables 
        draw(str(node), ":"+str(node), style_type="invisible")
    if node.getRightBranch():
        draw(str(node), str(node.getRightBranch()))
        stack.append(node.getRightBranch())      
    elif node.getLeftBranch():
        # draw any missing right branchs as invisible nodes/edges with dummy unique lables 
        draw(str(node), ";"+str(node), style_type="invisible") 
                
        
                       
#############################################################
# Initialize parameters for animation and search tree creation
#############################################################

# Instantiate the visualizeTree object
vT = visualizeTree(
    # fileCount: becomes part of the png file name to represent a sequence to our video tool: ffmpeg
    0,  
    # fileDir: directory to write png files  
    fileDir,  
    # fileName: base name for the png image files
    'bst_graph',
    # fileExt: file extension for png image files, other formats include .jpg, .tif, .pdf, .psd, etc...
    '.png',
    # vidFrames: the number of duplicate png images to stretch out video as defined in the ffmpeg video batch file
    1)

# Initialize a directional graph
#     Dot attributes:
#     graph_type = "graph" (edges drawn as lines)| "digraph" (edges drawn as arrows)
#     rankdir= "TB", "LR", "BT", "RL", corresponding to directed graphs drawn from top to bottom, from left to right, from bottom to top, and from right to left, respectively.
#     ranksep=float_value: rank separation in fraction of an inch 0.75 default, minimum vertical distance between nodes of equal rank
#     nodesep=float_value: node separation in fraction of an inch 0.25 default, minimum horizontal distance between nodes of equal rank
#     size = "string_value width, string_value height" in inches. Example: size="4, 8"
#     dpi=300 for better image quality, or dpi=96 for default value
#     optional layout="neato" | "sfpd" | "fpd" | "twopi" | "circo" to create a differently style for graph
#     pad=float_value for both width and height of pad around graph margins, in inches (.3 seems to be a good value)
#     bgcolor="red" set the background color
#     label="hello" set a text label just below the graph

graph = pydot.Dot(graph_type='digraph', nodesep=.5, pad=.3, size="19.2, 10.1")

# Set default node attributes
#     Node attributes:
#     style = 'filled' | 'invisible' | 'diagonals' | 'rounded'
#     shape = 'box' | 'ellipse' | 'circle' | 'point' | 'triangle'
#     height and width float_value inches, for example: height=1.5, width=1.5
#     text control: 'fontcolor', 'fontsize', 'label', 'fontname',  
graph.set_node_defaults(style="filled", fillcolor="grey")

# Set edge attributes
#     Edge attributes:
#     style     = 'dashed' | 'dotted' | 'solid' | 'invis' | 'bold'
#     arrowhead = 'box' | 'crow' | 'diamond' | 'dot' | 'inv' | 'none' | 'tee' | 'vee'
#     place a label: label="and back we go again", labelfontcolor="#009933", fontsize="10.0"
#     Adjust weighted flexibility in edge drawings: weight="0" for maximum flex, "3" for 
#     minlen=2 minimum edge length in inches (default is 1
#     weight="0" to "100"
graph.set_edge_defaults(color="blue", arrowhead="vee")


##################################################################
# Draw and animate binary search tree during a BFS or DFS search
##################################################################

# initialize graph. 
#    Use BFS traversal so graph will be created without reflection
#     produces the initial png files for use in generating a video with the png2mp4.bat program
#     update vidFrames to make this segment of video 3 seconds longer than the search portion of video 
vT.searchTree(root, sketchTree)
vT.setVidFrames(3)
vT.updateGraph()

# search for a node using helper functions for BFS or DFS traversal
#     each element of the tree will be highlighted with separate png files generated for the video
#     update vidFrames to make this segment of video 1 second long for highlight and return to default color
vT.setVidFrames(1)

# select one of these search options:
if searchName:
    searchNameFcn = {'DFSOrdered': DFSOrdered, 'DFS': DFS, 'BFS': BFS}
    vT.searchTree(root, searchNameFcn[searchName], findValue)

# extend the final segment of video for 3 more frames (or 3 seconds in video)
vT.setVidFrames(3)
vT.updateGraph()


################################################
# Display final ping image
################################################

# open a SPIDER image and convert to byte
#format
im = Image.open(vT.getFileName())

rootTk = Tkinter.Tk()  
# A root window for displaying objects

# Convert the Image object into a TkPhoto 
#object
tkimage = ImageTk.PhotoImage(im)

# Put it in the display window
Tkinter.Label(rootTk, image=tkimage).pack() 

rootTk.mainloop() # Start the GUI
