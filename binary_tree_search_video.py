# Animating a Binary Search Tree using Python, GraphViz, and ffmeg utility
# Project home: http://www.embeddedcomponents.com/blogs/2013/12/visualizing-software-tree-structures/

# Inspired by MITx 6.00.1x "Introduction to Computer Science and Programming"
# As taught by Professor Eric Grimson, Chairman of EECS Department, MIT
# Fall 2013, http://www.edx.org

# Developed by Ron Fredericks, Video Technologist, at LectureMaker LLC, http://www.LectureMaker.com
# MIT License, Copyright (c) 2013, Ron Fredericks
# Free to use following these terms: http://opensource.org/licenses/MIT 

# This project allows you to do the following:
#   1) design any searchable tree class, then instantiate the tree with data,
#       see "class binaryTree(object)" in this demo.
#   2) Use the provided "class visualizeTree(object)" to create a PNG image of the tree
#       as well as to create a sequence of PNG images for use in generating a video of the search path.
#   2-a) Helper functions "DFS()" and "BFS()" can be used to animate searching the tree by depth or breadth,
#       or use the code to create your own helper functions to test your own search algorithms.
#   3) The code completes with a PNG graphical display of the last image generated by this program,
#       to help you determine if this run of the program is useful for creation of mpeg4 video.
#   4) Generate an mpeg-4 video using the PNG image sequence generated by the "visualizeTree object",
#       Command line example (use double "%%" if this command is in a Windows batch file): 
#       ffmpeg -f image2 -r 1 -start_number 00001 -i bst_graph%05d.png -vcodec mpeg4 -r 12 -y movie.mp4

# The following free open source programs should be installed on your computer:
#   GraphViz: Graph visualization tool: http://www.graphviz.org/ 
#   FFmpeg: Cross-platform solution to record, convert and stream audio and video: http://www.ffmpeg.org/

# The following python module should be installed into your environment:
#   pydot: a python interface to Graphvize's Dot language: https://code.google.com/p/pydot/

# The following phyton modules are used for display of individual PNG images:
#   Tkinter: standard python GUI: https://wiki.python.org/moin/TkInter
#   Image and ImageTk: the python image library: http://www.pythonware.com/products/pil/ 



import pydot


###########################################
# Create a balanced binary tree
###########################################

# This code can be replaced with any experimental tree

class binaryTree(object):
    def __init__(self, value):
        self.value = value
        self.leftBranch = None
        self.rightBranch = None
        self.parent = None 
    def setLeftBranch(self, node):
        self.leftBranch = node
    def setRightBranch(self, node):
        self.rightBranch = node
    def setParent(self, parent):
        self.parent = parent
    def getValue(self):
        return self.value
    def getLeftBranch(self):
        return self.leftBranch
    def getRightBranch(self):
        return self.rightBranch
    def getParent(self):
        return self.parent
    def __str__(self):
        return str(self.value)

n5 = binaryTree(5)
n2 = binaryTree(2)
n1 = binaryTree(1)
n4 = binaryTree(4)
n8 = binaryTree(8)
n6 = binaryTree(6)
n7 = binaryTree(7)
n3 = binaryTree(3)

n5.setLeftBranch(n2)
n2.setParent(n5)
n5.setRightBranch(n8)
n8.setParent(n5)
n2.setLeftBranch(n1)
n1.setParent(n2)
n2.setRightBranch(n4)
n4.setParent(n2)
n8.setLeftBranch(n6)
n6.setParent(n8)
n6.setRightBranch(n7)
n7.setParent(n6)
n4.setLeftBranch(n3)
n3.setParent(n4)


#############################################################
# Graph tree as a png file - an object with helper functions
#############################################################
             
# Class to generate a binary search tree drawing, 
#   or to search for and draw highlight images of the tree's nodes.
# External helper search method functions supported: DFS() and BFS()  

class visualizeTree(object):
    def __init__(self, fileCount, fileDir, fileName, fileExt, vidFrames):
        self.fileCount = fileCount  # integer, part of the fullFileName when generating PNG image sequences
        self.fileDir = fileDir      # string, full directory to where PNG files will be stored
        self.fileName = fileName    # string, base name of the file 
        self.fileExt = fileExt      # string, image file extension (currently ".png" is the only supported type)
        self.vidFrames = vidFrames  # integer, a counter used generate duplicate copies of the PNG image files,
                                    #   a way to stretch the video time line.
        
        self.treeList = []       # storage for the DFS or BFS tree search as a queue or stack
        self.nodeNames = {}      # store each node name (key) with each node's pyDot object (value)
        self.fullFileName = ""   # store the current full file name for png images

    # allow user to change the number of duplicate png images to generate (ie stretch or shrink video time)        
    def setVidFrames(self, vidFrames):
        self.vidFrames = vidFrames

    # Find is string representing the node to search and highlight, or None to display full binary tree 
    # Returns True if node is found, or False if node is not found, or False when drawing the full tree (not searching)  
    def searchTree(self, root, method, find=None):
        self.treeList = [root]
        while len(self.treeList) > 0:
            node = self.treeList.pop(0)
            if find==str(node):
                self.highlightNodeFound(str(node))
                return True
            elif find!=None:
                self.blinkNodeTraversed(str(node))            
            method(node, self.treeList, self.draw, find)    
        return False

    # Function to draw a node and an edge of a Binary Tree
    def draw(self, parent_name, child_name, fill_color="grey"):
    
        edge = pydot.Edge(parent_name, child_name)
        graph.add_edge(edge)     

        if not self.nodeNames:
            # root node identified (the top most tree element)
            self.nodeNames[parent_name] = pydot.Node(parent_name, label="Root: " + parent_name, fillcolor=fill_color)
            graph.add_node(self.nodeNames[parent_name]) 
        if (parent_name not in self.nodeNames) or ("Leaf:" in graph.obj_dict['nodes'][parent_name][0]['attributes']['label']):
            # node (a tree element with leaves) identified       
            self.nodeNames[parent_name] = pydot.Node(parent_name, label="Node: " + parent_name, fillcolor=fill_color)
            graph.add_node(self.nodeNames[parent_name])
        if child_name not in self.nodeNames:
            # leaf element identified (a parent with no children) 
            self.nodeNames[child_name] = pydot.Node(child_name, label="Leaf: " + child_name, fillcolor=fill_color)
            graph.add_node(self.nodeNames[child_name])
              
    # Function to animate the found node in a search tree        
    def highlightNodeFound(self, node):
        graph.add_node(pydot.Node(node, fillcolor="green"))
        self.updateGraph()      

    # Function to animate a node being traversed in a search tree    
    def blinkNodeTraversed(self, node):
        graph.add_node(pydot.Node(node, fillcolor="red"))
        self.updateGraph()
        graph.add_node(pydot.Node(node, fillcolor="grey"))
        self.updateGraph()        
        
    # set the file name based on directory, name, count and extension in support of our ffmpeg png to video batch file       
    def setFileName(self):
        self.fullFileName = self.fileDir + self.fileName + '%05d' % self.fileCount + self.fileExt
    
    # get the current full file name 
    def getFileName(self):
        return self.fullFileName
    
    # write multiple copies of the same png image in support of ffmpeg png to video batch file
    def updateGraph(self):
        for i in range(0, self.vidFrames):
            self.fileCount += 1
            self.setFileName()
            graph.write_png(self.fullFileName)   

# Helper search method functions for use with visualizeTree's method named "searchTree()"

# Depth First Search: Start at root followed by all nodes on left followed by right.
# Uses a Queue: First in First out (FIFO)  
# Creates a graph that is a mirror image of original Binary Tree
# When find parameter is set to "None", draw the complete tree while searching for next element,
#  otherwise, skip drawing and just use the queue.insert() feature for searching.
def DFS(node, queue, draw, find):
    if node.getRightBranch():
        if find==None: 
            draw(str(node), str(node.getRightBranch()))
        queue.insert(0, node.getRightBranch())
    if node.getLeftBranch():
        if find==None:
            draw(str(node), str(node.getLeftBranch()))
        queue.insert(0, node.getLeftBranch())   

# Breadth First Search: Start at root followed by each child from left to right
# Uses a Stack: Last in First out (LIFO)    
# Creates a graph of a Binary Tree 
# When find parameter is set to "None", draw the complete tree while searching for next element,
#  otherwise, skip drawing and just use the stack.append() feature for searching.
def BFS(node, stack, draw, find):
    if node.getLeftBranch():
        if find==None: 
            draw(str(node), str(node.getLeftBranch()))
        stack.append(node.getLeftBranch())       
    if node.getRightBranch():
        if find==None: 
            draw(str(node), str(node.getRightBranch()))
        stack.append(node.getRightBranch())                              

                
#############################################################
# Initialize parameters for animation and search tree creation
#############################################################

# Instantiate the visualizeTree object
vT = visualizeTree(
    # fileCount: becomes part of the png file name to represent a sequence to our video tool: ffmpeg
    0,  
    # fileDir: directory to write png files  
    "C:\\Users\\Ron Fredericks\\Documents\\LectureMaker\\Projects\\MOOC\\EDx\\cs600.1\\Video\\vidImages\\",  
    # fileName: base name for the png image files
    'bst_graph',
    # fileExt: file extension for png image files, other formats include .jpg, .tif, .pdf, .psd, etc...
    '.png',
    # vidFrames: the number of duplicate png images to stretch out video as defined in the ffmpeg video batch file
    1)

# Initialize a directional graph
#     Dot attributes:
#     graph_type = "graph" (edges drawn as lines)| "digraph" (edges drawn as arrows)
#     rankdir='LR': draw graph on its side from left to right
#     ranksep=float_value: rank separation in fraction of an inch 0.75 default, minimum vertical distance between nodes of equal rank
#     nodesep=float_value: node separation in fraction of an inch 0.25 default, minimum vertical distance between nodes of equal rank
#     size = "string_value width, string_value height" in inches. Example: size="4, 8"
graph = pydot.Dot(graph_type='digraph')

# Set default node attributes
#     Node attributes:
#     style = 'filled' | 'invisible' | 'diagonals' | 'rounded'
#     shape = 'box' | 'ellipse' | 'circle' | 'point' | 'triangle'
#     height and width float_value inches, for example: height=1.5, width=1.5
#     text control: 'fontcolor', 'fontsize', 'label', 'fontname',  
graph.set_node_defaults(style="filled", fillcolor="grey")

# Set edge attributes
#     Edge attributes:
#     style     = 'dashed' | 'dotted' | 'solid' | 'invis' | 'bold'
#     arrowhead = 'box' | 'crow' | 'diamond' | 'dot' | 'inv' | 'none' | 'tee' | 'vee'
#     place a label: label="and back we go again", labelfontcolor="#009933", fontsize="10.0"
graph.set_edge_defaults(color="blue", arrowhead="vee")


##################################################################
# Draw and animate binary search tree during a BFS or DFS search
##################################################################

# initialize graph. 
#    Use BFS traversal so graph will be created without reflection
#     produces the initial png files for use in generating a video with the png2mp4.bat program
#     update vidFrames to make this segment of video 3 seconds longer than the search portion of video 
vT.searchTree(n5, BFS)
vT.setVidFrames(3)
vT.updateGraph()

# search for a node using helper functions for BFS or DFS traversal
#     each element of the tree will be highlighted with separate png files generated for the video
#     update vidFrames to make this segment of video 1 second long for highlight and return to default color
vT.setVidFrames(1)
vT.searchTree(n5, DFS, "7")

# extend the final segment of video for 3 more frames (or 3 seconds in video)
vT.setVidFrames(3)
vT.updateGraph()


################################################
# Display final ping image
################################################

# import first Image and the graphics package Tkinter
import Tkinter 
import Image, ImageTk
# open a SPIDER image and convert to byte
format
im = Image.open(vT.getFileName())

root = Tkinter.Tk()  
# A root window for displaying objects

 # Convert the Image object into a TkPhoto 
object
tkimage = ImageTk.PhotoImage(im)

Tkinter.Label(root, image=tkimage).pack() 
# Put it in the display window

root.mainloop() # Start the GUI
